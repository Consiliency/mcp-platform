const fs = require('fs');
const path = require('path');

/**
 * Environment Variable Loader for MCP Gateway
 * Loads API keys and environment variables from .env file and system environment
 */
class EnvLoader {
  constructor() {
    this.envPath = path.join(__dirname, '.env');
    this.envVars = {};
    this.loadedFromFile = false;
  }

  /**
   * Load environment variables from .env file and system
   */
  load() {
    // First, load from .env file if it exists
    if (fs.existsSync(this.envPath)) {
      try {
        const envContent = fs.readFileSync(this.envPath, 'utf8');
        this.parseEnvFile(envContent);
        this.loadedFromFile = true;
        console.log(`Loaded environment variables from ${this.envPath}`);
      } catch (error) {
        console.error('Error loading .env file:', error);
      }
    } else {
      console.log('.env file not found, using system environment variables only');
    }

    // Merge with system environment variables (system takes precedence)
    this.mergeWithSystemEnv();
    
    return this.envVars;
  }

  /**
   * Parse .env file content
   */
  parseEnvFile(content) {
    const lines = content.split('\n');
    
    lines.forEach(line => {
      // Skip empty lines and comments
      if (!line || line.trim().startsWith('#')) return;
      
      const [key, ...valueParts] = line.split('=');
      if (key && valueParts.length > 0) {
        const value = valueParts.join('=').trim();
        // Remove quotes if present
        this.envVars[key.trim()] = value.replace(/^["']|["']$/g, '');
      }
    });
  }

  /**
   * Merge with system environment variables
   */
  mergeWithSystemEnv() {
    // Common API key patterns to look for
    const patterns = [
      /_API_KEY$/,
      /_TOKEN$/,
      /_SECRET$/,
      /_PASSWORD$/,
      /_CLIENT_ID$/,
      /_CLIENT_SECRET$/,
      /_ACCESS_KEY$/,
      /_URL$/,
      /_URI$/,
      /_HOST$/,
      /_PORT$/,
      /_USERNAME$/,
      /_DATABASE$/,
      /_KEYSPACE$/,
      /_REGION$/,
      /_DOMAIN$/,
      /_PATH$/,
      /_CONFIG$/,
      /_ACCOUNT_/,
      /_TENANT_/,
      /_SUBSCRIPTION_/,
      /_ORG$/,
      /_TEAM_/
    ];

    // Check both regular and MCP_ prefixed versions
    Object.keys(process.env).forEach(key => {
      if (patterns.some(pattern => pattern.test(key)) || key.startsWith('MCP_')) {
        // System env takes precedence
        this.envVars[key] = process.env[key];
      }
    });
  }

  /**
   * Get environment variables for a specific server
   */
  getServerEnv(serverConfig) {
    const serverEnv = {};
    
    if (serverConfig.environment) {
      Object.keys(serverConfig.environment).forEach(key => {
        // Check for the key in loaded env vars
        if (this.envVars[key]) {
          serverEnv[key] = this.envVars[key];
        } 
        // Also check for MCP_ prefixed version
        else if (this.envVars[`MCP_${key}`]) {
          serverEnv[key] = this.envVars[`MCP_${key}`];
        }
        // Use default value from config if available
        else if (serverConfig.environment[key]) {
          serverEnv[key] = serverConfig.environment[key];
        }
      });
    }
    
    return serverEnv;
  }

  /**
   * Save environment variables to .env file
   */
  save(envVars) {
    const lines = [];
    
    // Add header
    lines.push('# MCP Gateway Environment Variables');
    lines.push('# Generated by MCP Gateway');
    lines.push(`# Last updated: ${new Date().toISOString()}`);
    lines.push('');
    
    // Group by category
    const categories = {
      'Cloud Providers': ['AWS_', 'AZURE_', 'GOOGLE_', 'GCP_', 'DIGITALOCEAN_', 'CLOUDFLARE_', 'VULTR_', 'LINODE_', 'HEROKU_', 'VERCEL_', 'NETLIFY_'],
      'Databases': ['POSTGRES_', 'MYSQL_', 'MONGODB_', 'REDIS_', 'CASSANDRA_', 'ELASTICSEARCH_', 'NEO4J_', 'ORACLE_', 'MSSQL_'],
      'Source Control': ['GITHUB_', 'GITLAB_', 'BITBUCKET_', 'SVN_', 'P4'],
      'Communication': ['SLACK_', 'DISCORD_', 'TEAMS_', 'TWILIO_', 'SENDGRID_', 'MAILGUN_'],
      'Development Tools': ['STRIPE_', 'PAYPAL_', 'SENTRY_', 'DATADOG_', 'BROWSERSTACK_', 'SONARQUBE_'],
      'Search & AI': ['BRAVE_', 'TAVILY_', 'SERPER_', 'EXA_', 'OPENAI_', 'ANTHROPIC_'],
      'Project Management': ['JIRA_', 'CONFLUENCE_', 'NOTION_', 'ASANA_', 'TRELLO_'],
      'Other': []
    };
    
    // Categorize env vars
    const categorized = {};
    Object.keys(categories).forEach(cat => categorized[cat] = []);
    
    Object.keys(envVars).forEach(key => {
      let added = false;
      for (const [category, prefixes] of Object.entries(categories)) {
        if (category !== 'Other' && prefixes.some(prefix => key.startsWith(prefix))) {
          categorized[category].push(key);
          added = true;
          break;
        }
      }
      if (!added) {
        categorized['Other'].push(key);
      }
    });
    
    // Write categorized env vars
    Object.entries(categorized).forEach(([category, keys]) => {
      if (keys.length > 0) {
        lines.push(`# ${category}`);
        keys.sort().forEach(key => {
          const value = envVars[key] || '';
          lines.push(`${key}=${value}`);
        });
        lines.push('');
      }
    });
    
    try {
      fs.writeFileSync(this.envPath, lines.join('\n'));
      console.log(`Saved environment variables to ${this.envPath}`);
      return true;
    } catch (error) {
      console.error('Error saving .env file:', error);
      return false;
    }
  }

  /**
   * Check which required keys are missing for a server
   */
  getMissingKeys(serverConfig) {
    const missing = [];
    
    if (serverConfig.environment) {
      Object.keys(serverConfig.environment).forEach(key => {
        const value = this.getServerEnv(serverConfig)[key];
        if (!value || value === '') {
          missing.push(key);
        }
      });
    }
    
    return missing;
  }
}

module.exports = EnvLoader;